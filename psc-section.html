<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PSC Girder Section Properties (with Haunch)</title>

  <!-- PDF libs (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --panel: rgba(255,255,255,0.08);
      --panel2: rgba(255,255,255,0.06);
      --line: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);

      /* Better contrast colors */
      --shapeFill: rgba(125, 211, 252, 0.35);   /* light cyan fill */
      --shapeStroke: rgba(255,255,255,0.85);    /* bright outline */
      --haunchFill: rgba(167, 139, 250, 0.32);  /* violet fill */
      --axis: rgba(255, 214, 102, 0.95);        /* centroid line */
      --canvasBg: rgba(0,0,0,0.28);             /* svg background */
      --accent: #7dd3fc;
      --accent2:#a78bfa;
      --shadow: 0 24px 60px rgba(0,0,0,.45);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1000px 600px at 20% 10%, rgba(125,211,252,.18), transparent 60%),
        radial-gradient(900px 500px at 80% 20%, rgba(167,139,250,.16), transparent 55%),
        var(--bg);
      min-height:100vh;
    }
    .wrap{max-width:1100px;margin:0 auto;padding:22px 16px 44px;}
    .top{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:14px;}
    .brand{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.2px;}
    .dot{width:10px;height:10px;border-radius:50%;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      box-shadow:0 0 0 6px rgba(125,211,252,.10);}
    .btn{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:12px;border:1px solid var(--line);
      background:rgba(255,255,255,.06);text-decoration:none;color:var(--text);
      font-weight:600;font-size:14px; cursor:pointer;
    }
    .btn:hover{background:rgba(255,255,255,.10)}
    .btn.primary{
      border:none;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color:#071022;
    }
    .grid{display:grid;grid-template-columns:380px 1fr;gap:14px}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}
    .panel{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid var(--line); border-radius:18px; box-shadow:var(--shadow);
      padding:16px; backdrop-filter: blur(10px);
    }
    h1{margin:0;font-size:18px}
    .muted{color:var(--muted);font-size:13px;line-height:1.55}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
    .field label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    .field input{
      width:100%;padding:10px 10px;border-radius:12px;border:1px solid var(--line);
      background:rgba(0,0,0,.18);color:var(--text);outline:none;
    }
    .field input:focus{border-color:rgba(125,211,252,.55)}
    .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .pill{display:inline-block;font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);
      background:rgba(255,255,255,.04);color:var(--muted)}
    .warn{color:#ffd27d;font-size:13px;margin-top:10px}
    .ok{color:#a7f3d0;font-size:13px;margin-top:10px}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    td{padding:10px;border-bottom:1px solid var(--line);font-size:14px}
    td:nth-child(1){color:var(--muted);width:52%}
    .svgBox{
      border:1px solid var(--line);border-radius:16px;background:var(--canvasBg);
      overflow:hidden;
    }
    .small{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>

<body>
<div class="wrap">
  <div class="top">
    <div class="brand"><span class="dot"></span> PSC Girder Section Properties (with Haunch)</div>
    <a class="btn" href="index.html">← Back to Home</a>
  </div>

  <div class="grid">
    <!-- Inputs -->
    <div class="panel">
      <h1>Inputs (mm)</h1>
      <div class="muted">
        Standard PSC I-girder (top flange + haunch trapezoid + web + bottom flange).
        Outputs: Area A, centroid ȳ (from bottom), Ixx (about centroid), Ztop, Zbot.
      </div>

      <div class="row">
        <div class="field">
          <label>Overall depth, D</label>
          <input id="D" type="number" value="1800" min="1" step="1">
        </div>
        <div class="field">
          <label>Web thickness, tw</label>
          <input id="tw" type="number" value="200" min="1" step="1">
        </div>

        <div class="field">
          <label>Top flange width, bt</label>
          <input id="bt" type="number" value="900" min="1" step="1">
        </div>
        <div class="field">
          <label>Top flange thickness, tt</label>
          <input id="tt" type="number" value="200" min="1" step="1">
        </div>

        <div class="field">
          <label>Bottom flange width, bb</label>
          <input id="bb" type="number" value="700" min="1" step="1">
        </div>
        <div class="field">
          <label>Bottom flange thickness, tb</label>
          <input id="tb" type="number" value="250" min="1" step="1">
        </div>

        <div class="field">
          <label>Haunch depth, hh</label>
          <input id="hh" type="number" value="150" min="0" step="1">
        </div>
        <div class="field">
          <label>Haunch bottom width, bh</label>
          <input id="bh" type="number" value="400" min="0" step="1">
        </div>
      </div>

      <div class="actions">
        <button class="btn primary" id="calcBtn" type="button">Calculate</button>
        <button class="btn" id="pdfBtn" type="button">Download PDF</button>
        <button class="btn" id="resetBtn" type="button">Reset</button>
        <span class="pill">Units: mm, mm², mm⁴, mm³</span>
      </div>

      <div id="msg"></div>

      <div class="small">
        Notes: Haunch top width is assumed = <code>tw</code>. Web “clear” height reduces by <code>hh</code>.
        Chamfers & box girder can be added as separate options/pages later.
      </div>
    </div>

    <!-- Graphic + Results -->
    <div class="panel" id="reportArea">
      <div style="display:flex;align-items:flex-end;justify-content:space-between;gap:10px;flex-wrap:wrap;">
        <div>
          <h1>Section (graphic)</h1>
          <div class="muted">Better contrast: canvas background is dark, section is bright.</div>
        </div>
        <div class="muted" id="stamp"></div>
      </div>

      <div class="svgBox" style="margin-top:10px;">
        <svg id="svg" viewBox="0 0 900 520" width="100%" height="520" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="PSC section">
          <rect x="0" y="0" width="900" height="520" fill="transparent"></rect>
          <g id="shape"></g>
          <g id="axis"></g>
          <g id="dims"></g>
        </svg>
      </div>

      <div style="margin-top:14px;">
        <h1>Results</h1>
        <table>
          <tbody>
            <tr><td>Area, A</td><td id="A">—</td></tr>
            <tr><td>Centroid from bottom, ȳ</td><td id="ybar">—</td></tr>
            <tr><td>Ixx about centroid</td><td id="Ixx">—</td></tr>
            <tr><td>Section modulus at top, Ztop</td><td id="Ztop">—</td></tr>
            <tr><td>Section modulus at bottom, Zbot</td><td id="Zbot">—</td></tr>
          </tbody>
        </table>
        <div class="small">PDF report includes the inputs, graphic, and results.</div>
      </div>
    </div>
  </div>
</div>

<script>
  const el = (id) => document.getElementById(id);

  function fmt(x, decimals=1) {
    if (!isFinite(x)) return "—";
    return x.toLocaleString(undefined, { maximumFractionDigits: decimals });
  }

  function nowStamp(){
    const d = new Date();
    return d.toLocaleString();
  }

  function validate(d) {
    const errs = [];
    if ([d.D,d.tw,d.bt,d.tt,d.bb,d.tb].some(v => v <= 0)) errs.push("All girder dimensions must be > 0.");
    if (d.hh < 0 || d.bh < 0) errs.push("Haunch inputs must be ≥ 0.");
    if (d.tw > Math.max(d.bt, d.bb)) errs.push("Web thickness tw should not exceed flange widths.");
    if (d.D <= d.tt + d.tb + d.hh) errs.push("D must be greater than (tt + tb + hh).");
    if (d.hh > 0 && d.bh < d.tw) errs.push("If hh > 0, haunch bottom width bh should be ≥ tw.");
    return errs;
  }

  // Rectangle helper: b (width), h (height), y0 from bottom
  function rectProps(b, h, y0) {
    const A = b * h;
    const y = y0 + h/2;               // centroid from bottom
    const Icg = b * Math.pow(h,3) / 12; // about own centroid axis
    return {A, y, Icg};
  }

  // Isosceles trapezoid haunch (top width = a, bottom width = b, height = h)
  // Located with its TOP at yTop (from bottom).
  function haunchProps(a, b, h, yTop){
    // Area
    const A = (a + b) * h / 2;

    // Centroid from TOP of trapezoid (towards bottom):
    // y_from_top = h*(2a + b) / (3*(a + b))
    const y_from_top = h * (2*a + b) / (3*(a + b));
    const y = yTop - y_from_top; // centroid from bottom

    // I about axis parallel to bases through trapezoid centroid:
    // Icg = h^3 * (a^2 + 4ab + b^2) / (36*(a + b))
    const Icg = Math.pow(h,3) * (a*a + 4*a*b + b*b) / (36*(a + b));

    return {A, y, Icg};
  }

  function compute() {
    const d = {
      D: +el("D").value,
      tw: +el("tw").value,
      bt: +el("bt").value,
      tt: +el("tt").value,
      bb: +el("bb").value,
      tb: +el("tb").value,
      hh: +el("hh").value,
      bh: +el("bh").value
    };

    const errs = validate(d);
    const msg = el("msg");
    msg.innerHTML = "";

    if (errs.length) {
      msg.innerHTML = `<div class="warn">⚠ ${errs.join(" ")}</div>`;
      return null;
    }
    msg.innerHTML = `<div class="ok">✓ Inputs look OK</div>`;

    const hw = d.D - d.tt - d.tb - d.hh; // web clear height (between bottom flange and haunch)

    // Rectangles:
    // Bottom flange: y0=0
    const r1 = rectProps(d.bb, d.tb, 0);

    // Web rectangle: y0=tb, height=hw
    const r2 = rectProps(d.tw, hw, d.tb);

    // Haunch trapezoid: top located at yTop = tb + hw + hh (which is bottom of top flange)
    // Top flange bottom is at y = D - tt. That equals tb + hw + hh.
    // So yTop = D - tt
    let h1 = null;
    if (d.hh > 0 && d.bh > 0){
      h1 = haunchProps(d.tw, d.bh, d.hh, d.D - d.tt);
    }

    // Top flange: y0 = D - tt
    const r3 = rectProps(d.bt, d.tt, d.D - d.tt);

    const parts = [r1, r2, r3];
    if (h1) parts.push(h1);

    const A = parts.reduce((s,p)=>s+p.A,0);
    const ybar = parts.reduce((s,p)=>s+p.A*p.y,0) / A;

    const Ixx = parts.reduce((s,p)=>{
      const dy = p.y - ybar;
      return s + p.Icg + p.A * dy * dy;
    }, 0);

    const yTop = d.D - ybar;
    const yBot = ybar;

    const Ztop = Ixx / yTop;
    const Zbot = Ixx / yBot;

    return {d, hw, A, ybar, Ixx, Ztop, Zbot};
  }

  function draw(res){
    if (!res) return;
    const {d, hw, ybar} = res;

    const gShape = el("shape");
    const gAxis  = el("axis");
    const gDims  = el("dims");
    gShape.innerHTML = "";
    gAxis.innerHTML  = "";
    gDims.innerHTML  = "";

    const W = 900, H = 520, pad = 70;

    // Choose bounding width (max of flange widths and haunch bottom width and web)
    const maxB = Math.max(d.bt, d.bb, d.tw, d.bh);
    const sx = (W - 2*pad) / maxB;
    const sy = (H - 2*pad) / d.D;
    const s  = Math.min(sx, sy);

    const secW = maxB * s, secH = d.D * s;
    const x0 = (W - secW)/2;
    const y0 = (H - secH)/2;

    // Map section coordinates (mm) to SVG (px)
    const X = (x_mm) => x0 + x_mm * s;
    const Y = (y_mm) => y0 + (d.D - y_mm) * s;

    const cx = maxB/2;

    // Centers
    const topX = cx - d.bt/2;
    const botX = cx - d.bb/2;
    const webX = cx - d.tw/2;

    // Fill/stroke
    const rect = (x, y, w, h, fill) =>
      `<rect x="${x}" y="${y}" width="${w}" height="${h}"
             fill="${fill}" stroke="var(--shapeStroke)" stroke-width="2" rx="10" ry="10"/>`;

    // Bottom flange: from y=0 to tb
    gShape.insertAdjacentHTML("beforeend",
      rect(X(botX), Y(d.tb), d.bb*s, d.tb*s, "var(--shapeFill)")
    );

    // Web: from y=tb to tb+hw
    gShape.insertAdjacentHTML("beforeend",
      rect(X(webX), Y(d.tb + hw), d.tw*s, hw*s, "var(--shapeFill)")
    );

    // Haunch: trapezoid under top flange (if hh > 0)
    if (d.hh > 0 && d.bh > 0){
      const haTopY = d.D - d.tt;     // top of haunch
      const haBotY = haTopY - d.hh;  // bottom of haunch

      const haTopX1 = cx - d.tw/2;
      const haTopX2 = cx + d.tw/2;
      const haBotX1 = cx - d.bh/2;
      const haBotX2 = cx + d.bh/2;

      gShape.insertAdjacentHTML("beforeend", `
        <polygon points="
          ${X(haTopX1)},${Y(haTopY)}
          ${X(haTopX2)},${Y(haTopY)}
          ${X(haBotX2)},${Y(haBotY)}
          ${X(haBotX1)},${Y(haBotY)}
        " fill="var(--haunchFill)" stroke="var(--shapeStroke)" stroke-width="2"/>
      `);
    }

    // Top flange: from y=D-tt to D
    gShape.insertAdjacentHTML("beforeend",
      rect(X(topX), Y(d.D), d.bt*s, d.tt*s, "var(--shapeFill)")
    );

    // Centroidal axis line
    gAxis.insertAdjacentHTML("beforeend", `
      <line x1="${X(0)}" y1="${Y(ybar)}" x2="${X(maxB)}" y2="${Y(ybar)}"
            stroke="var(--axis)" stroke-width="3" stroke-dasharray="10,8"/>
      <circle cx="${X(cx)}" cy="${Y(ybar)}" r="5" fill="var(--axis)"/>
    `);

    // Light bounding box
    gDims.insertAdjacentHTML("beforeend", `
      <rect x="${x0}" y="${y0}" width="${secW}" height="${secH}"
            fill="transparent" stroke="rgba(255,255,255,.12)" stroke-width="2" rx="16" ry="16"/>
      <text x="18" y="30" fill="rgba(255,255,255,.85)" font-size="14">D=${d.D} mm</text>
      <text x="18" y="52" fill="rgba(255,255,255,.75)" font-size="13">
        bt=${d.bt}, tt=${d.tt}, tw=${d.tw}, bb=${d.bb}, tb=${d.tb}, hh=${d.hh}, bh=${d.bh} (mm)
      </text>
    `);
  }

  function updateUI(){
    const res = compute();
    if (!res) return;

    el("A").textContent    = `${fmt(res.A,0)} mm²`;
    el("ybar").textContent = `${fmt(res.ybar,1)} mm`;
    el("Ixx").textContent  = `${res.Ixx.toExponential(3)} mm⁴`;
    el("Ztop").textContent = `${res.Ztop.toExponential(3)} mm³`;
    el("Zbot").textContent = `${res.Zbot.toExponential(3)} mm³`;

    el("stamp").textContent = `Generated: ${nowStamp()}`;

    draw(res);
  }

  async function downloadPDF(){
    const res = compute();
    if (!res) return;

    const report = el("reportArea");
    const btn = el("pdfBtn");
    const old = btn.textContent;
    btn.textContent = "Preparing PDF…";
    btn.disabled = true;

    try{
      const canvas = await html2canvas(report, { scale: 2, backgroundColor: "#0b1220" });
      const imgData = canvas.toDataURL("image/png");

      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: "p", unit: "mm", format: "a4" });

      // Fit image to A4 width with margins
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const margin = 10;
      const maxW = pageW - 2*margin;

      // Compute scaled height keeping aspect ratio
      const imgW = maxW;
      const imgH = (canvas.height / canvas.width) * imgW;

      let y = margin;
      pdf.setFont("helvetica", "bold");
      pdf.setFontSize(14);
      pdf.text("PSC Girder Section Properties Report", margin, y);
      y += 7;

      pdf.setFont("helvetica", "normal");
      pdf.setFontSize(10);
      pdf.text(`Generated: ${nowStamp()}`, margin, y);
      y += 6;

      // Add captured report (graphic + results)
      if (imgH <= (pageH - y - margin)) {
        pdf.addImage(imgData, "PNG", margin, y, imgW, imgH);
      } else {
        // If too tall, split pages roughly
        // Add first page image portion by scaling; simplest: add full image on multiple pages by vertical offset
        const pxPerMm = canvas.width / imgW;
        const pageContentH = (pageH - y - margin);
        const pageContentPx = pageContentH * pxPerMm;

        let sy = 0;
        let page = 0;

        while (sy < canvas.height) {
          if (page > 0) {
            pdf.addPage();
            y = margin;
          }
          // Create slice canvas
          const slice = document.createElement("canvas");
          slice.width = canvas.width;
          slice.height = Math.min(pageContentPx, canvas.height - sy);
          const ctx = slice.getContext("2d");
          ctx.drawImage(canvas, 0, sy, canvas.width, slice.height, 0, 0, canvas.width, slice.height);
          const sliceData = slice.toDataURL("image/png");
          const sliceHmm = (slice.height / slice.width) * imgW;
          pdf.addImage(sliceData, "PNG", margin, y, imgW, sliceHmm);
          sy += slice.height;
          page++;
        }
      }

      pdf.save("psc_section_report.pdf");
    } finally {
      btn.textContent = old;
      btn.disabled = false;
    }
  }

  el("calcBtn").addEventListener("click", updateUI);
  el("pdfBtn").addEventListener("click", downloadPDF);

  el("resetBtn").addEventListener("click", () => {
    el("D").value = 1800;
    el("tw").value = 200;
    el("bt").value = 900;
    el("tt").value = 200;
    el("bb").value = 700;
    el("tb").value = 250;
    el("hh").value = 150;
    el("bh").value = 400;
    el("msg").innerHTML = "";
    el("A").textContent = el("ybar").textContent = el("Ixx").textContent = el("Ztop").textContent = el("Zbot").textContent = "—";
    el("shape").innerHTML = el("axis").innerHTML = el("dims").innerHTML = "";
    el("stamp").textContent = "";
    updateUI();
  });

  // Initial render
  updateUI();
</script>
</body>
</html>
